---
description: Django-specific development guidelines and best practices
alwaysApply: false
---
# Django Guidelines

## Backend Server Startup

### Docker-Only Server Execution
The backend must always be started using Docker infrastructure:

✅ Allowed:
- `docker-compose up`
- `docker-compose up --build`
- `docker compose up`

❌ Not allowed:
- `python manage.py runserver`
- Any direct Django `runserver` usage

Reason:
The backend environment depends on Docker-based services such as Postgres, Redis, Celery, and networking. Running Django directly locally will result in inconsistent environments, failed dependencies, and invalid dev setup.

This rule enforces Django-specific development guidelines and best practices for the Noteably platform.

## App Registration and Configuration

### App Structure
Each Django app must be properly registered and configured:

```python
# ✅ Good app registration in settings/base.py
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    # Third-party apps
    'rest_framework',
    'corsheaders',
    'channels',
    
    # Local apps
    'apps.accounts',
    'apps.ingestion',
    'apps.transcription',
    'apps.generation',
    'apps.storage',
    'apps.tasks',
    'apps.analytics',
]

# ✅ Good app configuration in apps.py
from django.apps import AppConfig

class ApiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.api'
    verbose_name = 'API'
    
    def ready(self):
        import apps.api.signals
```

### URL Configuration
Each app must have its own `urls.py` and be included in the main URL configuration:

```python
# ✅ Good URL structure in apps/api/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()
router.register(r'sources', views.SourceContentViewSet)
router.register(r'transcriptions', views.TranscriptionViewSet)
router.register(r'generated-content', views.GeneratedContentViewSet)
router.register(r'summaries', views.SummaryViewSet)
router.register(r'notes', views.NotesViewSet)
router.register(r'flashcards', views.FlashcardViewSet)
router.register(r'quizzes', views.QuizViewSet)

app_name = 'api'
urlpatterns = [
    path('', include(router.urls)),
    path('sources/<int:source_id>/transcribe/', views.start_transcription, name='start-transcription'),
    path('transcriptions/<int:transcription_id>/generate/', views.generate_content, name='generate-content'),
    path('generated-content/<int:content_id>/refine/', views.refine_content, name='refine-content'),
]

# ✅ Good main URL configuration in config/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/v1/', include('apps.api.urls')),
    path('api/v1/auth/', include('apps.accounts.urls')),
    path('api/v1/billing/', include('apps.subscriptions.urls')),
]
```

## Model Guidelines

### Model Definition
All models must follow consistent patterns:

```python
# ✅ Good model structure
from django.db import models
from django.contrib.auth.models import User
from django.core.validators import MinLengthValidator, MaxLengthValidator

class SourceContent(models.Model):
    """Represents uploaded content from various sources (YouTube, files, text)."""
    SOURCE_TYPES = [
        ('youtube', 'YouTube'),
        ('file', 'File Upload'),
        ('text', 'Text Input'),
    ]
    
    # Fields
    title = models.CharField(
        max_length=200,
        validators=[MinLengthValidator(2), MaxLengthValidator(200)],
        help_text="Content title (2-200 characters)"
    )
    source_type = models.CharField(
        max_length=20,
        choices=SOURCE_TYPES,
        help_text="Type of content source"
    )
    source_url = models.URLField(blank=True, null=True, help_text="YouTube URL or external link")
    file_reference = models.ForeignKey(
        'storage.FileReference',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='source_contents',
        help_text="Reference to uploaded file"
    )
    raw_text = models.TextField(blank=True, help_text="Direct text input")
    metadata = models.JSONField(default=dict, help_text="Extracted metadata (duration, language, etc.)")
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='source_contents'
    )
    status = models.CharField(
        max_length=20,
        default='pending',
        choices=[
            ('pending', 'Pending'),
            ('processing', 'Processing'),
            ('completed', 'Completed'),
            ('failed', 'Failed'),
        ]
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # Meta
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'Source Content'
        verbose_name_plural = 'Source Contents'
        indexes = [
            models.Index(fields=['user', 'status']),
            models.Index(fields=['source_type', 'created_at']),
        ]
    
    # Methods
    def __str__(self):
        return f"{self.title} ({self.source_type})"
    
    def has_transcription(self):
        return hasattr(self, 'transcription') and self.transcription.status == 'completed'
    
    def get_duration(self):
        return self.metadata.get('duration', 0)
```

### Model Managers
Use custom managers for complex queries:

```python
# ✅ Good manager usage
class SourceContentManager(models.Manager):
    def for_user(self, user):
        return self.filter(user=user)
    
    def by_source_type(self, source_type):
        return self.filter(source_type=source_type)
    
    def completed(self):
        return self.filter(status='completed')
    
    def pending(self):
        return self.filter(status='pending')
    
    def recent(self, days=30):
        from django.utils import timezone
        since = timezone.now() - timezone.timedelta(days=days)
        return self.filter(created_at__gte=since)
    
    def with_transcriptions(self):
        return self.filter(transcription__status='completed')

class SourceContent(models.Model):
    # ... fields ...
    
    objects = SourceContentManager()
    
    class Meta:
        # ... meta options ...
```

## Serializer Guidelines

### DRF Serializers
Always use `ModelSerializer` when possible and follow consistent patterns:

```python
# ✅ Good serializer structure
from rest_framework import serializers
from django.contrib.auth.models import User
from .models import Transaction, Category

class SourceContentListSerializer(serializers.ModelSerializer):
    transcription_status = serializers.CharField(source='transcription.status', read_only=True)
    duration_formatted = serializers.SerializerMethodField()
    
    class Meta:
        model = SourceContent
        fields = ['id', 'title', 'source_type', 'duration_formatted', 'status', 'transcription_status', 'created_at']
        read_only_fields = ['id', 'created_at']
    
    def get_duration_formatted(self, obj):
        duration = obj.get_duration()
        if duration:
            minutes = duration // 60
            seconds = duration % 60
            return f"{minutes}m {seconds}s"
        return None

class SourceContentDetailSerializer(serializers.ModelSerializer):
    transcription_text = serializers.CharField(source='transcription.text', read_only=True)
    file_url = serializers.CharField(source='file_reference.url', read_only=True)
    metadata_display = serializers.SerializerMethodField()
    
    class Meta:
        model = SourceContent
        fields = '__all__'
        read_only_fields = ['id', 'created_at', 'updated_at', 'status']
    
    def get_metadata_display(self, obj):
        return {
            'duration': obj.get_duration(),
            'language': obj.metadata.get('language', 'unknown'),
            'file_size': obj.metadata.get('file_size', 0),
        }
    
    def validate_title(self, value):
        if len(value) < 2:
            raise serializers.ValidationError("Title must be at least 2 characters")
        return value
    
    def validate_source_type(self, value):
        valid_types = ['youtube', 'file', 'text']
        if value not in valid_types:
            raise serializers.ValidationError(f"Source type must be one of {valid_types}")
        return value

class SourceContentCreateSerializer(serializers.ModelSerializer):
    class Meta:
        model = SourceContent
        fields = ['title', 'source_type', 'source_url', 'file_reference', 'raw_text', 'metadata']
    
    def create(self, validated_data):
        validated_data['user'] = self.context['request'].user
        validated_data['status'] = 'pending'
        return super().create(validated_data)
```

## View Guidelines

### ViewSet Structure
Use ViewSets for consistent API patterns:

```python
# ✅ Good ViewSet structure
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.shortcuts import get_object_or_404

from .models import Transaction, Category
from .serializers import TransactionListSerializer, TransactionDetailSerializer, TransactionCreateSerializer
from .tasks import categorize_transaction_task
from .permissions import IsOwnerOrReadOnly

class SourceContentViewSet(viewsets.ModelViewSet):
    serializer_class = SourceContentListSerializer
    permission_classes = [IsAuthenticated, IsOwnerOrReadOnly]
    
    def get_queryset(self):
        queryset = SourceContent.objects.for_user(self.request.user)
        
        # Filtering
        source_type = self.request.query_params.get('source_type')
        if source_type:
            queryset = queryset.filter(source_type=source_type)
        
        status = self.request.query_params.get('status')
        if status:
            queryset = queryset.filter(status=status)
        
        date_from = self.request.query_params.get('date_from')
        date_to = self.request.query_params.get('date_to')
        if date_from:
            queryset = queryset.filter(created_at__gte=date_from)
        if date_to:
            queryset = queryset.filter(created_at__lte=date_to)
        
        return queryset
    
    def get_serializer_class(self):
        if self.action == 'retrieve':
            return SourceContentDetailSerializer
        elif self.action == 'create':
            return SourceContentCreateSerializer
        return self.serializer_class
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)
    
    @action(detail=True, methods=['post'])
    def transcribe(self, request, pk=None):
        """Start transcription process for source content."""
        source_content = self.get_object()
        from apps.tasks.tasks import transcribe_content_task
        
        if source_content.status != 'completed':
            return Response(
                {'error': 'Source content must be completed before transcription'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        transcribe_content_task.delay(source_content.id)
        
        return Response({'status': 'transcription_started', 'source_id': source_content.id})
    
    @action(detail=False, methods=['get'])
    def stats(self, request):
        user_sources = self.get_queryset()
        stats = {
            'total': user_sources.count(),
            'by_type': {
                'youtube': user_sources.filter(source_type='youtube').count(),
                'file': user_sources.filter(source_type='file').count(),
                'text': user_sources.filter(source_type='text').count(),
            },
            'completed': user_sources.filter(status='completed').count(),
            'pending': user_sources.filter(status='pending').count(),
        }
        return Response(stats)
```

## Celery Task Guidelines

### Task Structure
Use Celery for heavy operations and follow consistent patterns:

```python
# ✅ Good Celery task structure
from celery import shared_task
from django.conf import settings
from django.core.mail import send_mail
import logging

logger = logging.getLogger(__name__)

@shared_task(bind=True, max_retries=3, default_retry_delay=60)
def transcribe_content_task(self, source_content_id):
    """
    Transcribe audio/video content from source.
    
    Args:
        source_content_id (int): ID of the SourceContent instance to transcribe
        
    Returns:
        str: Success message or raises exception
    """
    try:
        from apps.ingestion.models import SourceContent
        from apps.transcription.models import Transcription
        from apps.transcription.provider_selector import select_provider
        from apps.transcription.whisper_client import transcribe_with_whisper
        
        source_content = SourceContent.objects.get(id=source_content_id)
        
        # Update status
        source_content.status = 'processing'
        source_content.save()
        
        logger.info(f"Starting transcription for source content {source_content_id}")
        
        # Select transcription provider
        provider = select_provider(
            content_type=source_content.source_type,
            duration=source_content.get_duration()
        )
        
        # Transcribe content
        transcription_result = transcribe_with_whisper(
            file_reference=source_content.file_reference,
            language=source_content.metadata.get('language')
        )
        
        # Create transcription record
        transcription, created = Transcription.objects.update_or_create(
            source_content=source_content,
            defaults={
                'text': transcription_result['text'],
                'status': 'completed',
                'provider': provider,
                'metadata': transcription_result.get('metadata', {}),
            }
        )
        
        # Update source content status
        source_content.status = 'completed'
        source_content.save()
        
        logger.info(f"Successfully transcribed source content {source_content_id}")
        return f"Source content {source_content_id} transcribed successfully"
        
    except SourceContent.DoesNotExist:
        logger.error(f"Source content {source_content_id} not found")
        raise
    except Exception as exc:
        logger.error(f"Error transcribing source content {source_content_id}: {exc}")
        self.retry(countdown=60, exc=exc)

@shared_task(bind=True, max_retries=3)
def generate_study_materials_task(self, transcription_id, content_types):
    """Generate study materials (summaries, notes, flashcards, quizzes) from transcription."""
    try:
        from apps.transcription.models import Transcription
        from apps.generation.summary_generator import generate_summary
        from apps.generation.notes_generator import generate_notes
        from apps.generation.flashcard_generator import generate_flashcards
        from apps.generation.quiz_generator import generate_quiz
        
        transcription = Transcription.objects.get(id=transcription_id)
        
        results = {}
        
        if 'summary' in content_types:
            summary = generate_summary(transcription.text, length='medium')
            results['summary'] = summary
        
        if 'notes' in content_types:
            notes = generate_notes(transcription.text, style='outline')
            results['notes'] = notes
        
        if 'flashcards' in content_types:
            flashcards = generate_flashcards(transcription.text, count=10)
            results['flashcards'] = flashcards
        
        if 'quiz' in content_types:
            quiz = generate_quiz(transcription.text, type='multiple_choice', count=5)
            results['quiz'] = quiz
        
        logger.info(f"Successfully generated study materials for transcription {transcription_id}")
        return results
        
    except Transcription.DoesNotExist:
        logger.error(f"Transcription {transcription_id} not found")
        raise
    except Exception as exc:
        logger.error(f"Failed to generate study materials for transcription {transcription_id}: {exc}")
        self.retry(countdown=60, exc=exc)
```

## File Upload Guidelines

### Account Connection Handling
Use DRF for account connections and Plaid integration:

```python
# ✅ Good account connection handling
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from apps.accounts.models import Account
from .utils import validate_plaid_token, encrypt_token
from .tasks import sync_account_transactions

class SourceContentUploadView(APIView):
    permission_classes = [IsAuthenticated]
    
    def post(self, request):
        source_type = request.data.get('source_type')
        title = request.data.get('title')
        source_url = request.data.get('source_url')
        file = request.FILES.get('file')
        raw_text = request.data.get('raw_text')
        
        if not source_type:
            return Response(
                {'error': 'Source type is required'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Validate source type specific requirements
        if source_type == 'youtube' and not source_url:
            return Response(
                {'error': 'YouTube URL required for youtube source type'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        if source_type == 'file' and not file:
            return Response(
                {'error': 'File required for file source type'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        if source_type == 'text' and not raw_text:
            return Response(
                {'error': 'Text content required for text source type'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Create source content record
        from apps.ingestion.models import SourceContent
        from apps.storage.file_manager import store_file
        
        source_content_data = {
            'user': request.user,
            'title': title or 'Untitled',
            'source_type': source_type,
            'source_url': source_url,
            'raw_text': raw_text,
            'status': 'pending',
        }
        
        # Handle file upload
        if file:
            file_reference = store_file(file, user=request.user)
            source_content_data['file_reference'] = file_reference
        
        source_content = SourceContent.objects.create(**source_content_data)
        
        # Start processing (transcription if needed)
        if source_type in ['youtube', 'file']:
            from apps.tasks.tasks import transcribe_content_task
            transcribe_content_task.delay(source_content.id)
        
        return Response({
            'source_id': source_content.id,
            'status': 'created',
            'source_type': source_type
        }, status=status.HTTP_201_CREATED)
```

## Error Handling

### Consistent Error Responses
Use consistent error handling patterns:

```python
# ✅ Good error handling
from rest_framework.views import exception_handler
from rest_framework.response import Response
from rest_framework import status
import logging

logger = logging.getLogger(__name__)

def custom_exception_handler(exc, context):
    """Custom exception handler for consistent error responses."""
    response = exception_handler(exc, context)
    
    if response is not None:
        custom_response_data = {
            'status': 'error',
            'message': 'An error occurred',
            'details': response.data
        }
        response.data = custom_response_data
    
    return response

# ✅ Good validation error handling
class SourceContentCreateSerializer(serializers.ModelSerializer):
    def validate_title(self, value):
        if len(value) < 2:
            raise serializers.ValidationError({
                'title': 'Title must be at least 2 characters long'
            })
        return value
    
    def validate_source_type(self, value):
        valid_types = ['youtube', 'file', 'text']
        if value not in valid_types:
            raise serializers.ValidationError({
                'source_type': f'Source type must be one of {valid_types}'
            })
        return value
    
    def validate(self, data):
        # Ensure file_reference belongs to user if provided
        file_reference = data.get('file_reference')
        if file_reference and file_reference.user != self.context['request'].user:
            raise serializers.ValidationError({
                'file_reference': 'File reference does not belong to user'
            })
        
        # Validate source type specific requirements
        source_type = data.get('source_type')
        if source_type == 'youtube' and not data.get('source_url'):
            raise serializers.ValidationError({
                'source_url': 'YouTube URL is required for youtube source type'
            })
        
        if source_type == 'text' and not data.get('raw_text'):
            raise serializers.ValidationError({
                'raw_text': 'Text content is required for text source type'
            })
        
        return data
```

## Settings Configuration

### Environment-Specific Settings
Use separate settings files for different environments:

```python
# ✅ Good settings structure in settings/base.py
import os
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent.parent

# Security
SECRET_KEY = os.environ.get('SECRET_KEY')
DEBUG = False
ALLOWED_HOSTS = []

# Database
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.environ.get('DB_NAME'),
        'USER': os.environ.get('DB_USER'),
        'PASSWORD': os.environ.get('DB_PASSWORD'),
        'HOST': os.environ.get('DB_HOST', 'localhost'),
        'PORT': os.environ.get('DB_PORT', '5432'),
    }
}

# Celery
CELERY_BROKER_URL = os.environ.get('CELERY_BROKER_URL', 'redis://localhost:6379')
CELERY_RESULT_BACKEND = os.environ.get('CELERY_RESULT_BACKEND', 'redis://localhost:6379')

# File Storage
DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'
AWS_ACCESS_KEY_ID = os.environ.get('AWS_ACCESS_KEY_ID')
AWS_SECRET_ACCESS_KEY = os.environ.get('AWS_SECRET_ACCESS_KEY')
AWS_STORAGE_BUCKET_NAME = os.environ.get('AWS_STORAGE_BUCKET_NAME')
AWS_S3_REGION_NAME = os.environ.get('AWS_S3_REGION_NAME', 'us-east-1')

# ✅ Good development settings in settings/dev.py
from .base import *

DEBUG = True
ALLOWED_HOSTS = ['localhost', '127.0.0.1']

# Development-specific settings
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
CELERY_TASK_ALWAYS_EAGER = True
```

## Rationale

Django guidelines ensure:
- **Consistent architecture** - Predictable patterns across the application
- **Better maintainability** - Standard Django patterns are well-documented
- **Security** - Proper authentication, authorization, and input validation
- **Performance** - Efficient database queries and caching strategies
- **Scalability** - Proper use of Celery for background tasks
- **Team collaboration** - Familiar Django patterns reduce learning curve