---
description: Enforce consistent code structure and organization patterns
alwaysApply: false
---
# Code Structure

This rule enforces consistent code organization and structure patterns across the Noteably platform to improve maintainability and developer experience.

## Backend Structure

### Django App Organization

Each Django app should follow this consistent structure:

```
backend/apps/[app_name]/
├── __init__.py
├── admin.py          # Django admin configuration
├── apps.py           # App configuration
├── models.py         # Database models
├── serializers.py    # DRF serializers
├── views.py          # API views and view sets
├── urls.py           # URL routing
├── tasks.py          # Celery background tasks
├── consumers.py      # WebSocket consumers (if applicable)
├── utils.py          # App-specific utilities
├── tests.py          # Test cases
├── migrations/       # Database migrations
└── management/       # Django management commands
    └── commands/
```

### File Content Organization

#### Models (`models.py`)
```python
# ✅ Good structure
from django.db import models
from django.contrib.auth.models import User

# Constants
MAX_TITLE_LENGTH = 200
DEFAULT_STATUS = 'pending'

# Abstract base classes
class TimestampedModel(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        abstract = True

# Main models
class SourceContent(TimestampedModel):
    title = models.CharField(max_length=MAX_TITLE_LENGTH)
    source_type = models.CharField(max_length=20)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = 'Source Content'
        verbose_name_plural = 'Source Contents'
    
    def __str__(self):
        return self.title

# Managers
class SourceContentManager(models.Manager):
    def for_user(self, user):
        return self.filter(user=user)
```

#### Serializers (`serializers.py`)
```python
# ✅ Good structure
from rest_framework import serializers
from .models import Summary

# Base serializers
class BaseSourceContentSerializer(serializers.ModelSerializer):
    class Meta:
        model = SourceContent
        fields = ['id', 'title', 'source_type', 'created_at']

# Specific serializers
class SourceContentListSerializer(BaseSourceContentSerializer):
    transcription_status = serializers.CharField(source='transcription.status', read_only=True)

class SourceContentDetailSerializer(BaseSourceContentSerializer):
    transcription_text = serializers.CharField(source='transcription.text', read_only=True)
    status = serializers.CharField(read_only=True)
    
    class Meta(BaseSourceContentSerializer.Meta):
        fields = BaseSourceContentSerializer.Meta.fields + [
            'transcription_text', 'status', 'metadata'
        ]

class SourceContentCreateSerializer(serializers.ModelSerializer):
    class Meta:
        model = SourceContent
        fields = ['title', 'source_type', 'source_url', 'file_reference', 'raw_text']
    
    def validate_title(self, value):
        if len(value) < 2:
            raise serializers.ValidationError("Title must be at least 2 characters")
        return value
```

#### Views (`views.py`)
```python
# ✅ Good structure
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from .models import Summary
from .serializers import SummaryListSerializer, SummaryDetailSerializer
from .tasks import process_summary_task

class SourceContentViewSet(viewsets.ModelViewSet):
    queryset = SourceContent.objects.all()
    serializer_class = SourceContentListSerializer
    
    def get_serializer_class(self):
        if self.action == 'retrieve':
            return SourceContentDetailSerializer
        elif self.action == 'create':
            return SourceContentCreateSerializer
        return self.serializer_class
    
    def perform_create(self, serializer):
        source_content = serializer.save(user=self.request.user)
        transcribe_content_task.delay(source_content.id)
    
    @action(detail=True, methods=['post'])
    def transcribe(self, request, pk=None):
        source_content = self.get_object()
        transcribe_content_task.delay(source_content.id)
        return Response({'status': 'transcription_started'})
```

#### Tasks (`tasks.py`)
```python
# ✅ Good structure
from celery import shared_task
from django.conf import settings
from .models import Summary
from .ai_utils import transcribe_audio, generate_summary

@shared_task(bind=True, max_retries=3)
def transcribe_content_task(self, source_content_id):
    try:
        from apps.ingestion.models import SourceContent
        from apps.transcription.models import Transcription
        from apps.transcription.provider_selector import select_provider
        from apps.transcription.whisper_client import transcribe_with_whisper
        
        source_content = SourceContent.objects.get(id=source_content_id)
        
        # Update status
        source_content.status = 'processing'
        source_content.save()
        
        # Select provider and transcribe
        provider = select_provider(
            content_type=source_content.source_type,
            duration=source_content.get_duration()
        )
        
        transcription_result = transcribe_with_whisper(
            file_reference=source_content.file_reference,
            language=source_content.metadata.get('language')
        )
        
        # Create transcription record
        Transcription.objects.create(
            source_content=source_content,
            text=transcription_result['text'],
            status='completed',
            provider=provider
        )
        
        # Update source content status
        source_content.status = 'completed'
        source_content.save()
        
        return f"Source content {source_content_id} transcribed successfully"
        
    except Exception as exc:
        self.retry(countdown=60, exc=exc)
```

### Import Order

Follow this import order in all Python files:

```python
# ✅ Good import order
# 1. Standard library imports
import os
import json
from datetime import datetime

# 2. Third-party imports
from django.db import models
from rest_framework import serializers
from celery import shared_task

# 3. Local application imports
from .models import Summary
from ..accounts.models import User
from .utils import validate_file_type
```

## Frontend Structure

### Directory Organization

```
frontend/src/
├── components/
│   ├── common/           # Reusable UI components
│   │   ├── Button.jsx
│   │   ├── Modal.jsx
│   │   └── LoadingSpinner.jsx
│   ├── UploadInterface/ # Upload/Import Interface feature
│   │   ├── UploadInterface.jsx
│   │   ├── FileUpload.jsx
│   │   └── YouTubeInput.jsx
│   ├── StatusDisplay/   # Real-time Status Updates feature
│   │   ├── StatusDisplay.jsx
│   │   └── ProgressBar.jsx
│   ├── OutputViewer/     # Output Viewer feature
│   │   ├── OutputViewer.jsx
│   │   ├── SummaryViewer.jsx
│   │   └── NotesViewer.jsx
│   ├── pages/            # Page-level components
│   │   ├── Dashboard.jsx
│   │   ├── History.jsx
│   │   └── ContentDetail.jsx
│   └── layout/           # Layout components
│       ├── Navbar.jsx
│       └── Footer.jsx
├── hooks/                # Custom React hooks
│   ├── useAuth.js
│   ├── useTranscriptionWebSocket.js
│   ├── useSourceContent.js
│   └── useGeneratedContent.js
├── context/              # React context providers
│   ├── AuthContext.js
│   └── ContentContext.js
├── services/             # API services
│   ├── api.js
│   ├── websocket.js
│   └── export.js
├── utils/                # Utility functions
│   ├── formatters.js
│   └── validators.js
├── assets/               # Static assets
│   ├── images/
│   └── icons/
├── App.jsx
└── main.jsx
```

### Component Structure

#### Page Components
```jsx
// ✅ Good page component structure
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';

// Components
import Button from '../common/Button';
import LoadingSpinner from '../common/LoadingSpinner';

// Hooks
import { useAuth } from '../../hooks/useAuth';
import { useSummaryWebSocket } from '../../hooks/useSummaryWebSocket';

// Utils
import { uploadFile } from '../../utils/api';

// Constants
const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB

function UploadInterface() {
    // State
    const [file, setFile] = useState(null);
    const [sourceType, setSourceType] = useState('file');
    const [youtubeUrl, setYoutubeUrl] = useState('');
    const [rawText, setRawText] = useState('');
    const [uploading, setUploading] = useState(false);
    const [error, setError] = useState(null);
    
    // Hooks
    const { user } = useAuth();
    const navigate = useNavigate();
    const { connect, disconnect } = useTranscriptionWebSocket();
    
    // Effects
    useEffect(() => {
        connect();
        return () => disconnect();
    }, [connect, disconnect]);
    
    // Event handlers
    const handleFileSelect = (event) => {
        const selectedFile = event.target.files[0];
        if (selectedFile && selectedFile.size > MAX_FILE_SIZE) {
            setError('File size exceeds 500MB limit');
            return;
        }
        setFile(selectedFile);
        setError(null);
    };
    
    const handleSubmit = async (event) => {
        event.preventDefault();
        
        setUploading(true);
        setError(null);
        
        try {
            let sourceContent;
            
            if (sourceType === 'file' && file) {
                sourceContent = await uploadSourceFile(file);
            } else if (sourceType === 'youtube' && youtubeUrl) {
                sourceContent = await uploadYouTubeUrl(youtubeUrl);
            } else if (sourceType === 'text' && rawText) {
                sourceContent = await uploadTextInput(rawText);
            } else {
                setError('Please provide the required input for selected source type');
                setUploading(false);
                return;
            }
            
            navigate(`/content/${sourceContent.id}`);
        } catch (err) {
            setError(err.message || 'Failed to upload content');
        } finally {
            setUploading(false);
        }
    };
    
    // Render
    return (
        <div className="upload-interface">
            <h1>Upload Content</h1>
            
            <form onSubmit={handleSubmit}>
                <select 
                    value={sourceType} 
                    onChange={(e) => setSourceType(e.target.value)}
                >
                    <option value="file">File Upload</option>
                    <option value="youtube">YouTube URL</option>
                    <option value="text">Text Input</option>
                </select>
                
                {sourceType === 'file' && (
                    <input
                        type="file"
                        accept="audio/*,video/*,text/*"
                        onChange={handleFileSelect}
                    />
                )}
                
                {sourceType === 'youtube' && (
                    <input
                        type="url"
                        placeholder="Enter YouTube URL"
                        value={youtubeUrl}
                        onChange={(e) => setYoutubeUrl(e.target.value)}
                    />
                )}
                
                {sourceType === 'text' && (
                    <textarea
                        placeholder="Paste or type your text here"
                        value={rawText}
                        onChange={(e) => setRawText(e.target.value)}
                        rows={10}
                    />
                )}
                
                {error && <div className="error">{error}</div>}
                
                <Button
                    type="submit"
                    disabled={uploading}
                >
                    {uploading ? <LoadingSpinner /> : 'Upload'}
                </Button>
            </form>
        </div>
    );
}

export default UploadPage;
```

#### Custom Hooks
```jsx
// ✅ Good hook structure
import { useState, useEffect, useCallback } from 'react';
import { useAuth } from './useAuth';
import { api } from '../utils/api';

// Constants
const RECONNECT_DELAY = 5000;
const MAX_RECONNECT_ATTEMPTS = 5;

function useTranscriptionWebSocket(transcriptionId) {
    // State
    const [socket, setSocket] = useState(null);
    const [connected, setConnected] = useState(false);
    const [progress, setProgress] = useState(0);
    const [status, setStatus] = useState('pending');
    const [error, setError] = useState(null);
    
    // Dependencies
    const { token } = useAuth();
    
    // Callbacks
    const connect = useCallback(() => {
        if (!transcriptionId || !token) return;
        
        const ws = new WebSocket(`ws://localhost:8000/ws/transcription/${transcriptionId}/`);
        
        ws.onopen = () => {
            setConnected(true);
            setError(null);
        };
        
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'progress') {
                setProgress(data.progress);
            }
            if (data.type === 'status') {
                setStatus(data.status);
            }
        };
        
        ws.onclose = () => {
            setConnected(false);
            // Implement reconnection logic
        };
        
        ws.onerror = (error) => {
            setError('WebSocket connection failed');
        };
        
        setSocket(ws);
    }, [transcriptionId, token]);
    
    const disconnect = useCallback(() => {
        if (socket) {
            socket.close();
            setSocket(null);
            setConnected(false);
        }
    }, [socket]);
    
    // Effects
    useEffect(() => {
        connect();
        return disconnect;
    }, [connect, disconnect]);
    
    // Return hook interface
    return {
        connected,
        progress,
        status,
        error,
        connect,
        disconnect
    };
}

export { useTranscriptionWebSocket };
```

### Import Order (Frontend)

```jsx
// ✅ Good import order
// 1. React imports
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';

// 2. Third-party imports
import axios from 'axios';
import { toast } from 'react-toastify';

// 3. Local component imports
import Button from '../common/Button';
import LoadingSpinner from '../common/LoadingSpinner';

// 4. Local hook imports
import { useAuth } from '../../hooks/useAuth';

// 5. Local utility imports
import { api } from '../../utils/api';
import { formatDate } from '../../utils/formatters';

// 6. Local constant imports
import { MAX_FILE_SIZE } from '../../constants/limits';
```

## Function Organization

### Order of Functions Within Files

```python
# ✅ Good function order
# 1. Constants and configuration
MAX_RETRIES = 3
DEFAULT_TIMEOUT = 30

# 2. Helper functions (private)
def _validate_file_type(file_path):
    """Validate file type based on extension."""
    pass

def _generate_unique_filename(original_name):
    """Generate unique filename for storage."""
    pass

# 3. Main business logic functions
def process_uploaded_file(file):
    """Process uploaded file and return metadata."""
    pass

def create_summary_from_file(file, user):
    """Create summary record from uploaded file."""
    pass

# 4. Public API functions
def upload_file_endpoint(request):
    """Handle file upload API request."""
    pass

# 5. Exports (if applicable)
__all__ = ['upload_file_endpoint', 'create_summary_from_file']
```

## Rationale

Consistent code structure provides:
- **Predictable organization** - Developers know where to find specific code
- **Easier navigation** - Familiar patterns reduce cognitive load
- **Better maintainability** - Consistent structure makes refactoring safer
- **Team collaboration** - New team members can quickly understand the codebase
- **Tooling support** - IDEs can provide better autocomplete and refactoring
- **Code reviews** - Consistent structure makes reviews more efficient